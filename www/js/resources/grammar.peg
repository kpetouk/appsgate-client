{
  var variables = [];
  var targetType;
  var id;
  function getType(v)
  {
    if (typeof variables[v] !== 'undefined') {
      targetType = variables[v].type;
      id = variables[v].id;
    } else {
      error = { message : "unknown variable : " + v}
      throw error;
    }
  }
}
/*
 * Program
 */
pg = h:header _ d:declarations _ i:insts _
{
  p={};
  if (h['programname']) {
    p.programName = h['programname'];
  }
  if (h['author']) {
    p.author = h['author']; 
  }
  if (h['target']) {
    p.target = h['target'];
  }
  if (h['daemon']) {
    p.daemon = h['daemon'];
  }
  p.seqDefinitions=d;
  p.seqRules = [i];
  return p;
}

/*
 * Header
 */
header = h:headerInst*
{
header=[];
  h.forEach(function(e) {
     header[e.key.toLowerCase()] = e.value;
  });

  return header;
}

headerInst = daemonInst / hInst

hInst = t:str _ ":" _ v:str "\n" 
{
  return {key:t, value:v};
}

daemonInst = "daemon" _ ":" _ v:bool "\n"
{
  return {key:"daemon", value:v};
}

/*
 * Declarations
 */

declarations = v:var_decl*


var_decl = alias / var_comp

alias = v:var_name _ "=" _ o:object _
{
  o.var_name = v;
  variables[v] = o;
  return o;
}

var_comp = v:var_name _ "=" _ "[" _ o:var_list _ "]"
{
  
  obj = { type:'list', id:v, var_name:v, list:o};
  variables[v] = obj;
  return obj;
}

var_list = v:var_name sep o:var_list 
{
  return [{type:'variable',id: v}].concat(o);
}
 / v:var_name 
{
  return {type:'variable',id:v};
} 

var_name = v:str 
{
  return v;
}

/*
 * Instructions
 */
insts = i:inst sep is:insts
{
  return [i].concat(is);
} 
  / i:inst
{
  return [i];
}
  / "[" _ i:insts _ "]"
{
  return i;
}

inst = action / when / if

/*
 * Node Action
 */
action = v:var_name "." method:str "(" action:sentence ")"
{
   getType(v);
   return {type:'NodeAction',targetType:targetType,targetId:id,methodName:method,action:action};
   
}

/**
 * Node When
 */
when = "when(" e:evts sep i:insts ")" 
{
  return {type:'NodeWhen',events:e,seqRulesThen:i};
}

/**
 * Node events
 */

evts = evt
     / "[" e:evts "]"
{
  return e;
}
     / e:evt sep es:evts 
{
  return e.concat(es);
}

evt  = v:var_name "."  e:string "(\"" event:string "\")"
{
  getType(v);
  return {type:'nodeEvent',sourceType:targetType,eventName:e,sourceId:id,eventValue:event};
}

/*
 * Node If
 */
if = "if"i b:relBool sepTHEN t:insts sepELSE f:insts 
{
  return {type:'NodeIf',expBool: [[ b]],seqRulesTrue: [[]],seqRulesFalse:[[f]]};
}

relBool = _ "(" left:operand _ o:operator _ right:operand ")"
{
  return {type:'NodeRelationBool',operator:o,leftOperand:left,rightOperand:right};
}

/*
 * Node Function
*/
function =  v:var_name "." method:str "(\"" action:sentence "\"" sep retType:[isb] ")"
{
   getType(v);
   switch(retType) {
     case 'i':
        retType = 'number';
        break;
     case 's':
        retType = 'string';
        break;
     case 'b':
        retType = 'boolean';
        break;
   }
   return {targetId:id,methodName:method,returnType:retType,targetType:targetType,action:action};
}

/*
 * Basic elements
 */
targetId=c:[a-zA-Z0-9\_\-\.\:]+
{
  return c.join("");
}
str = c:[a-zA-Z0-9\_\-]+
{
  return c.join("");
}
sentence = "\"" c:[a-zA-Z0-9\_\-\ êéèùàîïû]+ "\""
{
  return c.join("");
} 
/ "\"\"" 
{
  return "";
}

operator = "==" / ">=" / "<="

operand= relBool / bool / stringValue / numValue / function
stringValue= "\"" c:str "\""
{
  obj.type="string";
  obj.value=c;
  return obj;
}
numValue= n:[0-9]+
{
  return {type:'number', value:n.join("")};
}
boolean = v:bool
{
  return {type:'boolean',value: v};
}
bool = "true"i/"false"i

/*
 * Separators
 */

sep = ([\ ]*[\n])+ / _ ";" _ / _ "," _

sepTHEN = _ "=>" _ / _ "then"i _
sepELSE = _ "else"i _

/* JSON parser based on the grammar described at http://json.org/. */

/* ===== Syntactical Elements ===== */

start
  = _ object:object { return object; }

object
  = "{" _ "}" _                 { return {};      }
  / "{" _ members:members "}" _ { return members; }

members
  = head:pair tail:("," _ pair)* {
      var result = {};
      result[head[0]] = head[1];
      for (var i = 0; i < tail.length; i++) {
        result[tail[i][2][0]] = tail[i][2][1];
      }
      return result;
    }

pair
  = name:string ":" _ value:value { return [name, value]; }

array
  = "[" _ "]" _                   { return [];       }
  / "[" _ elements:elements "]" _ { return elements; }

elements
  = head:value tail:("," _ value)* {
      var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][2]);
      }
      return result;
    }

value
  = string
  / number
  / object
  / array
  / "true" _  { return true;   }
  / "false" _ { return false;  }
  // FIXME: We can't return null here because that would mean parse failure.
  / "null" _  { return "null"; }

/* ===== Lexical Elements ===== */

string "string"
  = '"' '"' _             { return "";    }
  / '"' chars:chars '"' _ { return chars; }

chars
  = chars:char+ { return chars.join(""); }

char
  // In the original JSON grammar: "any-Unicode-character-except-"-or-\-or-control-character"
  = [^"\\\0-\x1F\x7f]
  / '\\"'  { return '"';  }
  / "\\\\" { return "\\"; }
  / "\\/"  { return "/";  }
  / "\\b"  { return "\b"; }
  / "\\f"  { return "\f"; }
  / "\\n"  { return "\n"; }
  / "\\r"  { return "\r"; }
  / "\\t"  { return "\t"; }
  / "\\u" h1:hexDigit h2:hexDigit h3:hexDigit h4:hexDigit {
      return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
    }

number "number"
  = int_:int frac:frac exp:exp _ { return parseFloat(int_ + frac + exp); }
  / int_:int frac:frac _         { return parseFloat(int_ + frac);       }
  / int_:int exp:exp _           { return parseFloat(int_ + exp);        }
  / int_:int _                   { return parseFloat(int_);              }

int
  = digit19:digit19 digits:digits     { return digit19 + digits;       }
  / digit:digit
  / "-" digit19:digit19 digits:digits { return "-" + digit19 + digits; }
  / "-" digit:digit                   { return "-" + digit;            }

frac
  = "." digits:digits { return "." + digits; }

exp
  = e:e digits:digits { return e + digits; }

digits
  = digits:digit+ { return digits.join(""); }

e
  = e:[eE] sign:[+-]? { return e + sign; }

/*
 * The following rules are not present in the original JSON gramar, but they are
 * assumed to exist implicitly.
 *
 * FIXME: Define them according to ECMA-262, 5th ed.
 */

digit
  = [0-9]

digit19
  = [1-9]

hexDigit
  = [0-9a-fA-F]

/* ===== Whitespace ===== */

_ "whitespace"
  = whitespace*

// Whitespace is undefined in the original JSON grammar, so I assume a simple
// conventional definition consistent with ECMA-262, 5th ed.
whitespace
  = [ \t\n\r]
